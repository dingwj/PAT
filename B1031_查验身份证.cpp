// B1031
#include<stdio.h>
#include<string.h>

/*
    思路：
        step1: 立flag，表示是否所有身份证号都正确；初始值为 true(or 1);
        step2: 按字符数组的形式读入身份证号；对前17位，如果其中不存在非整数，则计算加权和。
		        将加权和 取模 11 得到校验码，若得到的校验码与原身份证号第18位不同，则该身份证号错误；反之则说明该身份证号码无误。
	
	注意：
		1. 只要前 17 位中存在非整数，就认定该身份证号有误，不再继续计算校验和！ 
		2. 使用数组来存储 权重 和 校验码 的对应关系，可以降低程序难度！ 
*/
int w[20] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};
char change[15] = {'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};

int main()
{
	int n;
	scanf("%d", &n);
	int flag = 1;
	char str[20];
	
	for(int i = 0; i < n; i++)
	{
		scanf("%s", str);
		int j;
		
		//计算前17位的加权和 
		int last = 0;
		for( j = 0; j < 17; j++)
		{
			if( !(str[j] >= '0' && str[j] <= '9') )
				break; // 如果存在 非数字 情况，则跳出 
			 
			last = last + (str[j] - '0') * w[j];
		}
		
		/* 
		  如果有 非数字 情况存在，
		   则 flag置否；且完整输出该身份证号； 
		*/ 
		if( j < 17 ) 
		{
			flag = 0;
			printf("%s\n", str);	
		}
		// 即使前17位都是数字，也要考虑校验码错误的情况； 
		else
		{
			//若 校验码 不等于该身份证号最后一位，则 flag置否，且完整输出该身份证号； 
			if( change[last % 11] != str[17] )
			{
				flag = 0;
				printf("%s\n", str);
			}
		}
	}
	
	if( flag == 1 )
	{
		printf("All passed");
	}
	
	return 0;	
}

